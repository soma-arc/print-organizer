#include "genmesh/mesher.h"
#include "genmesh/error_code.h"
#include "genmesh/log.h"

#include <openvdb/tools/VolumeToMesh.h>
#include <openvdb/io/File.h>

#include <cmath>
#include <cstring>
#include <fstream>

namespace genmesh {

MeshResult extract_mesh(const openvdb::FloatGrid::Ptr& grid,
                        double iso,
                        double adaptivity) {
    MeshResult result;

    if (!grid) {
        result.ok = false;
        result.exit_code = ExitCode::ProcessingError;
        result.error_code = std::string(E5001);
        result.error_msg = "Null grid passed to extract_mesh";
        log_error(E5001, result.error_msg);
        return result;
    }

    try {
        std::vector<openvdb::Vec3s> points;
        std::vector<openvdb::Vec3I> tris;
        std::vector<openvdb::Vec4I> quads;

        openvdb::tools::volumeToMesh(
            *grid, points, tris, quads, iso, adaptivity);

        result.mesh.points = std::move(points);
        result.mesh.original_tri_count = static_cast<int64_t>(tris.size());
        result.mesh.original_quad_count = static_cast<int64_t>(quads.size());

        // Reserve space for all triangles (original + 2 per quad)
        result.mesh.triangles.reserve(tris.size() + quads.size() * 2);

        // Add original triangles
        for (const auto& t : tris) {
            result.mesh.triangles.push_back({t[0], t[1], t[2]});
        }

        // Split quads → 2 triangles each: (0,1,2) + (0,2,3)  §7.1
        for (const auto& q : quads) {
            result.mesh.triangles.push_back({q[0], q[1], q[2]});
            result.mesh.triangles.push_back({q[0], q[2], q[3]});
        }

        // Count degenerate triangles (|cross product| near zero)
        const float eps = 1e-30f;
        for (const auto& tri : result.mesh.triangles) {
            const auto& p0 = result.mesh.points[tri.v0];
            const auto& p1 = result.mesh.points[tri.v1];
            const auto& p2 = result.mesh.points[tri.v2];
            auto e1 = p1 - p0;
            auto e2 = p2 - p0;
            auto cross_vec = e1.cross(e2);
            if (cross_vec.lengthSqr() < eps) {
                ++result.mesh.degenerate_count;
            }
        }

        if (result.mesh.degenerate_count > 0) {
            log_warn(W5001, "Degenerate triangles detected", {
                {"count", std::to_string(result.mesh.degenerate_count)},
            });
        }

        log_info("GENMESH_I0003", "Mesh extracted", {
            {"vertices", std::to_string(result.mesh.points.size())},
            {"triangles", std::to_string(result.mesh.triangles.size())},
            {"original_tris", std::to_string(result.mesh.original_tri_count)},
            {"original_quads", std::to_string(result.mesh.original_quad_count)},
            {"degenerate", std::to_string(result.mesh.degenerate_count)},
        });

        result.ok = true;
        result.exit_code = ExitCode::Success;

    } catch (const std::exception& e) {
        result.ok = false;
        result.exit_code = ExitCode::ProcessingError;
        result.error_code = std::string(E5001);
        result.error_msg = std::string("volumeToMesh failed: ") + e.what();
        log_error(E5001, result.error_msg);
    }

    return result;
}

StlWriteResult write_stl(const std::filesystem::path& path,
                         const MeshData& mesh) {
    StlWriteResult result;

    // Write to temp file, then rename for atomic write
    auto tmp_path = path;
    tmp_path += ".tmp";

    try {
        std::ofstream ofs(tmp_path, std::ios::binary);
        if (!ofs) {
            result.ok = false;
            result.exit_code = ExitCode::IoError;
            result.error_code = std::string(E2102);
            result.error_msg = "Failed to open temp STL file: " + tmp_path.string();
            log_error(E2102, result.error_msg);
            return result;
        }

        // 80-byte header: "Generated by genmesh" + zero padding  §7.1
        char header[80] = {};
        const char* hdr_text = "Generated by genmesh";
        std::memcpy(header, hdr_text, std::strlen(hdr_text));
        ofs.write(header, 80);

        // Triangle count (uint32_t little-endian)
        uint32_t tri_count = static_cast<uint32_t>(mesh.triangles.size());
        ofs.write(reinterpret_cast<const char*>(&tri_count), 4);

        const float eps = 1e-30f;

        // Write each triangle: normal(12B) + v0(12B) + v1(12B) + v2(12B) + attr(2B)
        for (const auto& tri : mesh.triangles) {
            const auto& p0 = mesh.points[tri.v0];
            const auto& p1 = mesh.points[tri.v1];
            const auto& p2 = mesh.points[tri.v2];

            // Compute normal: normalize(cross(v1-v0, v2-v0))
            auto e1 = p1 - p0;
            auto e2 = p2 - p0;
            auto cross_vec = e1.cross(e2);
            float len_sq = cross_vec.lengthSqr();

            float nx, ny, nz;
            if (len_sq < eps) {
                // Degenerate triangle → zero normal
                nx = ny = nz = 0.0f;
            } else {
                float len = std::sqrt(len_sq);
                nx = cross_vec[0] / len;
                ny = cross_vec[1] / len;
                nz = cross_vec[2] / len;
            }

            // Normal (3 x float32)
            ofs.write(reinterpret_cast<const char*>(&nx), 4);
            ofs.write(reinterpret_cast<const char*>(&ny), 4);
            ofs.write(reinterpret_cast<const char*>(&nz), 4);

            // Vertex 0 (3 x float32)
            float v[3] = {p0[0], p0[1], p0[2]};
            ofs.write(reinterpret_cast<const char*>(v), 12);

            // Vertex 1 (3 x float32)
            v[0] = p1[0]; v[1] = p1[1]; v[2] = p1[2];
            ofs.write(reinterpret_cast<const char*>(v), 12);

            // Vertex 2 (3 x float32)
            v[0] = p2[0]; v[1] = p2[1]; v[2] = p2[2];
            ofs.write(reinterpret_cast<const char*>(v), 12);

            // Attribute byte count (always 0)
            uint16_t attr = 0;
            ofs.write(reinterpret_cast<const char*>(&attr), 2);
        }

        ofs.close();
        if (ofs.fail()) {
            result.ok = false;
            result.exit_code = ExitCode::IoError;
            result.error_code = std::string(E2102);
            result.error_msg = "Failed to flush STL data to temp file";
            log_error(E2102, result.error_msg);
            return result;
        }

        // Atomic rename: temp → final path
        std::error_code ec;
        std::filesystem::rename(tmp_path, path, ec);
        if (ec) {
            result.ok = false;
            result.exit_code = ExitCode::IoError;
            result.error_code = std::string(E2102);
            result.error_msg = "Failed to rename temp STL file: " + ec.message();
            log_error(E2102, result.error_msg);
            return result;
        }

        log_info("GENMESH_I0004", "STL written", {
            {"path", path.string()},
            {"triangles", std::to_string(mesh.triangles.size())},
        });

        result.ok = true;
        result.exit_code = ExitCode::Success;

    } catch (const std::exception& e) {
        result.ok = false;
        result.exit_code = ExitCode::IoError;
        result.error_code = std::string(E2102);
        result.error_msg = std::string("STL write failed: ") + e.what();
        log_error(E2102, result.error_msg);

        // Clean up temp file on failure
        std::error_code ec;
        std::filesystem::remove(tmp_path, ec);
    }

    return result;
}

VdbWriteResult write_vdb(const std::filesystem::path& path,
                         const openvdb::FloatGrid::Ptr& grid) {
    VdbWriteResult result;

    if (!grid) {
        result.ok = false;
        result.exit_code = ExitCode::ProcessingError;
        result.error_code = std::string(E2103);
        result.error_msg = "Null grid passed to write_vdb";
        log_error(E2103, result.error_msg);
        return result;
    }

    try {
        openvdb::io::File file(path.string());
        openvdb::GridPtrVec grids;
        grids.push_back(grid);
        file.write(grids);
        file.close();

        log_info("GENMESH_I0005", "VDB written", {
            {"path", path.string()},
        });

        result.ok = true;
        result.exit_code = ExitCode::Success;

    } catch (const std::exception& e) {
        result.ok = false;
        result.exit_code = ExitCode::IoError;
        result.error_code = std::string(E2103);
        result.error_msg = std::string("VDB write failed: ") + e.what();
        log_error(E2103, result.error_msg);
    }

    return result;
}

}  // namespace genmesh
