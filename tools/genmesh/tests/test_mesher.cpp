#include "genmesh/mesher.h"
#include "genmesh/debug_generate.h"
#include "genmesh/vdb_builder.h"

#include <cassert>
#include <cmath>
#include <cstdint>
#include <cstring>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>

namespace fs = std::filesystem;

static int tests_run = 0;
static int tests_passed = 0;

#define RUN(fn)                                                \
    do {                                                       \
        ++tests_run;                                           \
        std::cout << "  " << #fn << " ... ";                   \
        try {                                                  \
            fn();                                              \
            ++tests_passed;                                    \
            std::cout << "OK\n";                               \
        } catch (const std::exception& e) {                    \
            std::cout << "FAIL: " << e.what() << "\n";         \
        }                                                      \
    } while (0)

#define ASSERT(expr)                                            \
    do {                                                        \
        if (!(expr))                                            \
            throw std::runtime_error(                           \
                std::string("Assertion failed: ") + #expr +     \
                " at line " + std::to_string(__LINE__));         \
    } while (0)

// ---------- helpers ----------

/// Create a sphere VDB grid for testing via debug_generate + build_vdb.
static openvdb::FloatGrid::Ptr make_sphere_grid() {
    genmesh::vdb_init();
    auto dg = genmesh::debug_generate("sphere", 4, 1.0f);
    assert(dg.ok);
    auto vdb = genmesh::build_vdb(dg.manifest, dg.bricks);
    assert(vdb.ok);
    return vdb.grid;
}

/// Temp directory helper — creates and returns unique temp dir.
static fs::path make_temp_dir(const std::string& prefix) {
    auto p = fs::temp_directory_path() / (prefix + "_genmesh_test");
    fs::create_directories(p);
    return p;
}

// ---------- T5.1 tests: extract_mesh ----------

void test_extract_mesh_sphere_produces_triangles() {
    auto grid = make_sphere_grid();
    auto r = genmesh::extract_mesh(grid, 0.0, 0.0);
    ASSERT(r.ok);
    ASSERT(!r.mesh.triangles.empty());
    ASSERT(!r.mesh.points.empty());
    ASSERT(static_cast<int64_t>(r.mesh.triangles.size()) ==
           r.mesh.original_tri_count + r.mesh.original_quad_count * 2);
}

void test_extract_mesh_null_grid_fails() {
    openvdb::FloatGrid::Ptr null_grid;
    auto r = genmesh::extract_mesh(null_grid);
    ASSERT(!r.ok);
    ASSERT(r.exit_code == genmesh::ExitCode::ProcessingError);
    ASSERT(r.error_code == "GENMESH_E5001");
}

void test_extract_mesh_quad_split_consistency() {
    // Verify total triangles = original_tris + 2 * original_quads
    auto grid = make_sphere_grid();
    auto r = genmesh::extract_mesh(grid, 0.0, 0.0);
    ASSERT(r.ok);
    int64_t expected = r.mesh.original_tri_count + 2 * r.mesh.original_quad_count;
    ASSERT(static_cast<int64_t>(r.mesh.triangles.size()) == expected);
}

void test_extract_mesh_vertex_indices_in_range() {
    auto grid = make_sphere_grid();
    auto r = genmesh::extract_mesh(grid, 0.0, 0.0);
    ASSERT(r.ok);
    uint32_t num_pts = static_cast<uint32_t>(r.mesh.points.size());
    for (const auto& tri : r.mesh.triangles) {
        ASSERT(tri.v0 < num_pts);
        ASSERT(tri.v1 < num_pts);
        ASSERT(tri.v2 < num_pts);
    }
}

void test_extract_mesh_empty_grid_zero_triangles() {
    genmesh::vdb_init();
    // Create an empty grid with no active voxels
    auto grid = openvdb::FloatGrid::create(1000.0f);
    grid->setGridClass(openvdb::GRID_LEVEL_SET);
    auto r = genmesh::extract_mesh(grid, 0.0, 0.0);
    ASSERT(r.ok);
    ASSERT(r.mesh.triangles.empty());
    ASSERT(r.mesh.points.empty());
}

// ---------- T5.2 tests: write_stl ----------

void test_write_stl_binary_format() {
    auto grid = make_sphere_grid();
    auto r = genmesh::extract_mesh(grid, 0.0, 0.0);
    ASSERT(r.ok);
    ASSERT(!r.mesh.triangles.empty());

    auto dir = make_temp_dir("stl_format");
    auto stl_path = dir / "mesh.stl";

    auto wr = genmesh::write_stl(stl_path, r.mesh);
    ASSERT(wr.ok);

    // Verify file exists
    ASSERT(fs::exists(stl_path));

    // Read and verify binary STL structure
    std::ifstream ifs(stl_path, std::ios::binary);
    ASSERT(ifs.good());

    // Header: 80 bytes
    char header[80] = {};
    ifs.read(header, 80);
    ASSERT(std::string(header, 20) == "Generated by genmesh");

    // Triangle count
    uint32_t tri_count = 0;
    ifs.read(reinterpret_cast<char*>(&tri_count), 4);
    ASSERT(tri_count == static_cast<uint32_t>(r.mesh.triangles.size()));

    // Expected file size: 80 + 4 + (50 * tri_count)
    auto expected_size = 80 + 4 + static_cast<std::streamoff>(50) * tri_count;
    ifs.seekg(0, std::ios::end);
    ASSERT(ifs.tellg() == expected_size);

    ifs.close();
    fs::remove_all(dir);
}

void test_write_stl_header_zero_padded() {
    // Create minimal mesh with 1 triangle
    genmesh::MeshData mesh;
    mesh.points.push_back(openvdb::Vec3s(0, 0, 0));
    mesh.points.push_back(openvdb::Vec3s(1, 0, 0));
    mesh.points.push_back(openvdb::Vec3s(0, 1, 0));
    mesh.triangles.push_back({0, 1, 2});

    auto dir = make_temp_dir("stl_header");
    auto stl_path = dir / "header_test.stl";

    auto wr = genmesh::write_stl(stl_path, mesh);
    ASSERT(wr.ok);

    std::ifstream ifs(stl_path, std::ios::binary);
    char header[80] = {};
    ifs.read(header, 80);

    // First 20 bytes: "Generated by genmesh"
    ASSERT(std::memcmp(header, "Generated by genmesh", 20) == 0);

    // Remaining bytes (20..79) should be zero
    for (int i = 20; i < 80; ++i) {
        ASSERT(header[i] == 0);
    }

    ifs.close();
    fs::remove_all(dir);
}

void test_write_stl_normal_computation() {
    // Triangle in XY plane: normal should be (0,0,1) or (0,0,-1)
    genmesh::MeshData mesh;
    mesh.points.push_back(openvdb::Vec3s(0, 0, 0));
    mesh.points.push_back(openvdb::Vec3s(1, 0, 0));
    mesh.points.push_back(openvdb::Vec3s(0, 1, 0));
    mesh.triangles.push_back({0, 1, 2});

    auto dir = make_temp_dir("stl_normal");
    auto stl_path = dir / "normal_test.stl";

    auto wr = genmesh::write_stl(stl_path, mesh);
    ASSERT(wr.ok);

    // Read normal from STL
    std::ifstream ifs(stl_path, std::ios::binary);
    ifs.seekg(84);  // skip header(80) + count(4)

    float nx, ny, nz;
    ifs.read(reinterpret_cast<char*>(&nx), 4);
    ifs.read(reinterpret_cast<char*>(&ny), 4);
    ifs.read(reinterpret_cast<char*>(&nz), 4);

    // cross((1,0,0)-(0,0,0), (0,1,0)-(0,0,0)) = cross((1,0,0),(0,1,0)) = (0,0,1)
    ASSERT(std::abs(nx) < 1e-5f);
    ASSERT(std::abs(ny) < 1e-5f);
    ASSERT(std::abs(nz - 1.0f) < 1e-5f);

    ifs.close();
    fs::remove_all(dir);
}

void test_write_stl_degenerate_normal_zero() {
    // Degenerate triangle: all vertices on a line
    genmesh::MeshData mesh;
    mesh.points.push_back(openvdb::Vec3s(0, 0, 0));
    mesh.points.push_back(openvdb::Vec3s(1, 0, 0));
    mesh.points.push_back(openvdb::Vec3s(2, 0, 0));  // collinear
    mesh.triangles.push_back({0, 1, 2});

    auto dir = make_temp_dir("stl_degen");
    auto stl_path = dir / "degen_test.stl";

    auto wr = genmesh::write_stl(stl_path, mesh);
    ASSERT(wr.ok);

    // Read normal
    std::ifstream ifs(stl_path, std::ios::binary);
    ifs.seekg(84);

    float nx, ny, nz;
    ifs.read(reinterpret_cast<char*>(&nx), 4);
    ifs.read(reinterpret_cast<char*>(&ny), 4);
    ifs.read(reinterpret_cast<char*>(&nz), 4);

    // Degenerate → (0,0,0)
    ASSERT(nx == 0.0f);
    ASSERT(ny == 0.0f);
    ASSERT(nz == 0.0f);

    ifs.close();
    fs::remove_all(dir);
}

void test_write_stl_temp_file_cleaned_up() {
    genmesh::MeshData mesh;
    mesh.points.push_back(openvdb::Vec3s(0, 0, 0));
    mesh.points.push_back(openvdb::Vec3s(1, 0, 0));
    mesh.points.push_back(openvdb::Vec3s(0, 1, 0));
    mesh.triangles.push_back({0, 1, 2});

    auto dir = make_temp_dir("stl_tmpclean");
    auto stl_path = dir / "clean_test.stl";
    auto tmp_path = stl_path;
    tmp_path += ".tmp";

    auto wr = genmesh::write_stl(stl_path, mesh);
    ASSERT(wr.ok);

    // Final file should exist, temp should not
    ASSERT(fs::exists(stl_path));
    ASSERT(!fs::exists(tmp_path));

    fs::remove_all(dir);
}

// ---------- T5.3 tests: write_vdb ----------

void test_write_vdb_produces_file() {
    auto grid = make_sphere_grid();

    auto dir = make_temp_dir("vdb_write");
    auto vdb_path = dir / "volume.vdb";

    auto wr = genmesh::write_vdb(vdb_path, grid);
    ASSERT(wr.ok);
    ASSERT(fs::exists(vdb_path));
    ASSERT(fs::file_size(vdb_path) > 0);

    fs::remove_all(dir);
}

void test_write_vdb_readable() {
    auto grid = make_sphere_grid();

    auto dir = make_temp_dir("vdb_read");
    auto vdb_path = dir / "volume.vdb";

    auto wr = genmesh::write_vdb(vdb_path, grid);
    ASSERT(wr.ok);

    // Read back and verify
    openvdb::io::File file(vdb_path.string());
    file.open();
    auto grids = file.getGrids();
    ASSERT(grids && !grids->empty());

    auto read_grid = openvdb::gridPtrCast<openvdb::FloatGrid>((*grids)[0]);
    ASSERT(read_grid);
    ASSERT(read_grid->activeVoxelCount() == grid->activeVoxelCount());

    file.close();
    fs::remove_all(dir);
}

void test_write_vdb_null_grid_fails() {
    openvdb::FloatGrid::Ptr null_grid;

    auto dir = make_temp_dir("vdb_null");
    auto vdb_path = dir / "null.vdb";

    auto wr = genmesh::write_vdb(vdb_path, null_grid);
    ASSERT(!wr.ok);
    ASSERT(wr.error_code == "GENMESH_E2103");

    fs::remove_all(dir);
}

// ---------- main ----------

int main() {
    std::cout << "=== test_mesher ===\n";

    // T5.1: extract_mesh
    RUN(test_extract_mesh_sphere_produces_triangles);
    RUN(test_extract_mesh_null_grid_fails);
    RUN(test_extract_mesh_quad_split_consistency);
    RUN(test_extract_mesh_vertex_indices_in_range);
    RUN(test_extract_mesh_empty_grid_zero_triangles);

    // T5.2: write_stl
    RUN(test_write_stl_binary_format);
    RUN(test_write_stl_header_zero_padded);
    RUN(test_write_stl_normal_computation);
    RUN(test_write_stl_degenerate_normal_zero);
    RUN(test_write_stl_temp_file_cleaned_up);

    // T5.3: write_vdb
    RUN(test_write_vdb_produces_file);
    RUN(test_write_vdb_readable);
    RUN(test_write_vdb_null_grid_fails);

    std::cout << "\n" << tests_passed << "/" << tests_run << " passed\n";
    return (tests_passed == tests_run) ? 0 : 1;
}
